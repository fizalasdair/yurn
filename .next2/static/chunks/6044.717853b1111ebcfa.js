"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6044],{83287:function(e,t,i){i.d(t,{W:function(){return r}});var s=i(6475),n=i(54146);class r extends n.Z{constructor(e){let{chains:t=s.gL9,options:i}=e;super(),this.chains=t,this.options=i}getBlockExplorerUrls(e){let t=e.explorers?.map(e=>e.url)??[];return t.length>0?t:void 0}isChainUnsupported(e){return!this.chains.some(t=>t.chainId===e)}updateChains(e){this.chains=e}}},50610:function(e,t,i){i.d(t,{A:function(){return r},C:function(){return a},R:function(){return h},S:function(){return c},U:function(){return d},a:function(){return o}});class s extends Error{constructor(e,t){let{cause:i,code:s,data:n}=t;if(!Number.isInteger(s))throw Error('"code" must be an integer.');if(!e||"string"!=typeof e)throw Error('"message" must be a nonempty string.');super(`${e}. Cause: ${JSON.stringify(i)}`),this.cause=i,this.code=s,this.data=n}}class n extends s{constructor(e,t){let{cause:i,code:s,data:n}=t;if(!(Number.isInteger(s)&&s>=1e3&&s<=4999))throw Error('"code" must be an integer such that: 1000 <= code <= 4999');super(e,{cause:i,code:s,data:n})}}class r extends Error{name="AddChainError";message="Error adding chain"}class a extends Error{name="ChainNotConfigured";constructor(e){let{chainId:t,connectorId:i}=e;super(`Chain "${t}" not configured for connector "${i}".`)}}class o extends Error{name="ConnectorNotFoundError";message="Connector not found"}class h extends s{name="ResourceUnavailable";constructor(e){super("Resource unavailable",{cause:e,code:-32002})}}class c extends n{name="SwitchChainError";constructor(e){super("Error switching chain",{cause:e,code:4902})}}class d extends n{name="UserRejectedRequestError";constructor(e){super("User rejected request",{cause:e,code:4001})}}},76044:function(e,t,i){i.d(t,{WalletConnectConnector:function(){return g}});var s=i(19485),n=i(241),r=i(16441),a=i(25137),o=i(83287),h=i(50610);i(54146);let c=new Set([1,137,10,42161,56]),d="eip155",l="wagmi.requestedChains",u="wallet_addEthereumChain",p="last-used-chain-id";class g extends o.W{id=a.w.walletConnect;name="WalletConnect";ready=!0;#e;#t;#i;constructor(e){super({...e,options:{isNewChainsStale:!0,...e.options}}),this.#i=e.options.storage,this.#s(),this.filteredChains=this.chains.length>50?this.chains.filter(e=>c.has(e.chainId)):this.chains}async connect(){let{chainId:e,pairingTopic:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};try{let i=e;if(!i){let e=await this.#i.getItem(p),t=e?parseInt(e):void 0;i=t&&!this.isChainUnsupported(t)?t:this.filteredChains[0]?.chainId}if(!i)throw Error("No chains found on connector.");let r=await this.getProvider();this.setupListeners();let a=await this.#n();if(r.session&&a&&await r.disconnect(),!r.session||a){let e=this.filteredChains.filter(e=>e.chainId!==i).map(e=>e.chainId);this.emit("message",{type:"connecting"}),await r.connect({pairingTopic:t,chains:[i],optionalChains:e.length>0?e:[i]}),await this.#r(this.filteredChains.map(e=>{let{chainId:t}=e;return t}))}let o=await r.enable();if(0===o.length)throw Error("No accounts found on provider.");let h=s.getAddress(o[0]),c=await this.getChainId(),d=this.isChainUnsupported(c);return{account:h,chain:{id:c,unsupported:d},provider:new n.Q(r)}}catch(e){if(/user rejected/i.test(e?.message))throw new h.U(e);throw e}}async disconnect(){let e=()=>{if("undefined"!=typeof localStorage)for(let e in localStorage)e.startsWith("wc@2")&&localStorage.removeItem(e)};e();let t=await this.getProvider(),i=async()=>{try{await t.disconnect()}catch(e){if(!/No matching key/i.test(e.message))throw e}finally{this.#a(),await this.#r([]),e()}};i()}async getAccount(){let{accounts:e}=await this.getProvider();if(0===e.length)throw Error("No accounts found on provider.");return s.getAddress(e[0])}async getChainId(){let{chainId:e}=await this.getProvider();return e}async getProvider(){let{chainId:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this.#e||await this.#s(),e&&await this.switchChain(e),!this.#e)throw Error("No provider found.");return this.#e}async getSigner(){let{chainId:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},[t,i]=await Promise.all([this.getProvider({chainId:e}),this.getAccount()]);return new n.Q(t,e).getSigner(i)}async isAuthorized(){try{let[e,t]=await Promise.all([this.getAccount(),this.getProvider()]),i=await this.#n();if(!e)return!1;if(i&&t.session){try{await t.disconnect()}catch{}return!1}return!0}catch{return!1}}async switchChain(e){let t=this.chains.find(t=>t.chainId===e);if(!t)throw new h.S(`Chain with ID: ${e}, not found on connector.`);try{let i=await this.getProvider(),s=this.#o(),n=this.#h(),a=s.includes(e);if(!a&&n.includes(u)){let s=t.explorers?.length?{blockExplorerUrls:[t.explorers[0].url]}:{};await i.request({method:u,params:[{chainId:r.hexValue(t.chainId),chainName:t.name,nativeCurrency:t.nativeCurrency,rpcUrls:[...t.rpc],...s}]});let n=await this.#c();n.push(e),await this.#r(n)}return await i.request({method:"wallet_switchEthereumChain",params:[{chainId:r.hexValue(e)}]}),t}catch(t){let e="string"==typeof t?t:t?.message;if(/user rejected request/i.test(e))throw new h.U(t);throw new h.S(t)}}async #s(){return this.#t||(this.#t=this.#d()),this.#t}async #d(){let{default:e,OPTIONAL_EVENTS:t,OPTIONAL_METHODS:s}=await i.e(2692).then(i.bind(i,32692)),[n,...r]=this.filteredChains.map(e=>{let{chainId:t}=e;return t});n&&(this.#e=await e.init({showQrModal:!1!==this.options.qrcode,projectId:this.options.projectId,optionalMethods:s,optionalEvents:t,chains:[n],optionalChains:r,metadata:{name:this.options.dappMetadata.name,description:this.options.dappMetadata.description||"",url:this.options.dappMetadata.url,icons:[this.options.dappMetadata.logoUrl||""]},rpcMap:Object.fromEntries(this.filteredChains.map(e=>[e.chainId,e.rpc[0]])),qrModalOptions:this.options.qrModalOptions}))}async #n(){let e=this.#h();if(e.includes(u)||!this.options.isNewChainsStale)return!1;let t=await this.#c(),i=this.filteredChains.map(e=>{let{chainId:t}=e;return t}),s=this.#o();return(!s.length||!!s.some(e=>i.includes(e)))&&!i.every(e=>t.includes(e))}async setupListeners(){this.#e&&(this.#a(),this.#e.on("accountsChanged",this.onAccountsChanged),this.#e.on("chainChanged",this.onChainChanged),this.#e.on("disconnect",this.onDisconnect),this.#e.on("session_delete",this.onDisconnect),this.#e.on("display_uri",this.onDisplayUri),this.#e.on("connect",this.onConnect))}#a(){this.#e&&(this.#e.removeListener("accountsChanged",this.onAccountsChanged),this.#e.removeListener("chainChanged",this.onChainChanged),this.#e.removeListener("disconnect",this.onDisconnect),this.#e.removeListener("session_delete",this.onDisconnect),this.#e.removeListener("display_uri",this.onDisplayUri),this.#e.removeListener("connect",this.onConnect))}async #r(e){await this.#i.setItem(l,JSON.stringify(e))}async #c(){let e=await this.#i.getItem(l);return e?JSON.parse(e):[]}#o(){if(!this.#e)return[];let e=this.#e.session?.namespaces[d]?.chains?.map(e=>parseInt(e.split(":")[1]||""));return e??[]}#h(){if(!this.#e)return[];let e=this.#e.session?.namespaces[d]?.methods;return e??[]}onAccountsChanged=e=>{0===e.length?this.emit("disconnect"):this.emit("change",{account:s.getAddress(e[0])})};onChainChanged=async e=>{let t=Number(e),i=this.isChainUnsupported(t);await this.#i.setItem(p,String(e)),this.emit("change",{chain:{id:t,unsupported:i}})};onDisconnect=async()=>{await this.#r([]),await this.#i.removeItem(p),this.emit("disconnect")};onDisplayUri=e=>{this.emit("message",{type:"display_uri",data:e})};onConnect=()=>{this.emit("connect",{provider:this.#e})}}}}]);